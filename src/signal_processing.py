from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

import numpy as np
import numpy.typing as npt
import scipy.interpolate
from signal_tl import Signal

TimeSeries = npt.NDArray[np.float_]
SignalDict = Dict[str, Signal]


def pick_n_dividing_points(
    target: np.ndarray, n: int, force_include_end=False
) -> np.ndarray:
    """Pick n points from the target array, such that the points are evenly distributed."""
    if n <= 0:
        raise ValueError(
            "n=#{n} given. Number of points to pick should be a positive integer."
        )
    elif n == 1 and force_include_end:
        raise ValueError("n=1 and force_include_end=True are not compatible.")

    if force_include_end:
        q = len(target) / (n - 1)
        idx = [*[int(np.floor(i * q)) for i in range(n - 1)], -1]
    else:
        q = len(target) / n
        idx = [int(np.floor(i * q)) for i in range(n)]
    return target[idx]


def generate_diff_signals(
    variable_name: str,
    control_points: TimeSeries,
    valuation: list[float],
    sampling_points: TimeSeries,
    max_deriv_order: int = 0,
) -> SignalDict:
    """Generate a signal over a given variable and its derivatives.
    The signal `x` is generated by a cubic spline interpolation of the control points.
    The derivatives are generated by taking the derivatives of the spline.
    Currently only n<=3 order of derivatives are supported.

    Args:
        variable_name: The name of the variable.
        control_points: Some timepoints to control the shape of the signal.
        valuation: The values of the signal at the control points. Must have the same length as
            `control_points`.
        times: The sampling points of the signal.
        max_deriv_order: The maximum order of derivatives to generate. Set to 0 to generate only
            the signal itself.

    Returns:
        A dictionary of signals. The key is the name of the signal, and the value is the signal.
        The derivatives are named as `x'`, `x''`, `x'''`, etc.
    """
    if max_deriv_order < 0:
        raise ValueError(
            "max_deriv_order=#{max_deriv_order} given."
            "Derivative order shoud be a non-negative integer."
        )
    elif max_deriv_order > 3:
        raise ValueError(
            "max_deriv_order=#{max_deriv_order} given."
            "Currently only n<=3 order of derivatives are supported."
        )

    spline = scipy.interpolate.CubicSpline(
        control_points,
        valuation,
        bc_type="natural",  # boundary condition. f''(0) == f''(T) == 0.
    )

    def nth_deriv(n):
        return Signal(spline(sampling_points, n), sampling_points)

    return {(variable_name + "'" * i): nth_deriv(i) for i in range(max_deriv_order + 1)}


@dataclass(frozen=True)
class VariableConfig:
    """A user-specified configuration for a variable"""

    variable_name: str
    max_derivative_order: int = 0
    #    lb: float = - np.inf  # Currently not supported
    #    ub: float = np.inf
    n_control_points: int = 3


@dataclass(frozen=True)
class SignalGenerator:
    """A utility class to generate signals (and their derivatives) from values at control points."""

    variables: list[VariableConfig]
    sampling_points: TimeSeries
    # method: str = "cubic"  # Currently only cubic spline is supported

    @property
    def n_all_control_points(self) -> int:
        return sum(v.n_control_points for v in self.variables)

    def generate_signal(self, values_at_control_points: list[float]) -> SignalDict:
        result = {}
        idx = 0
        for v in self.variables:
            values_for_v = values_at_control_points[idx : idx + v.n_control_points]
            control_points = pick_n_dividing_points(
                self.sampling_points, v.n_control_points
            )
            signal = generate_diff_signals(
                v.variable_name,
                control_points,
                values_for_v,
                self.sampling_points,
                v.max_derivative_order,
            )
            result.update(signal)
            idx += v.n_control_points
        return result

    def __call__(self, values_at_control_points: list[float]) -> SignalDict:
        return self.generate_signal(values_at_control_points)
