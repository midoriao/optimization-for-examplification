from typing import Dict, MutableMapping, Sequence

import numpy as np
import numpy.typing as npt
import scipy
from signal_tl import Signal

Trace = MutableMapping[str, Signal]
TimeSeries = npt.NDArray[np.float_]


def pick_n_dividing_points(
    target: np.ndarray, n: int, force_include_end=False
) -> np.ndarray:
    """Pick n points from the target array, such that the points are evenly distributed."""
    if n <= 0:
        raise ValueError(
            "n=#{n} given. Number of points to pick should be a positive integer."
        )
    elif n == 1 and force_include_end:
        raise ValueError(
            "n=1 and force_include_end=True are not compatible."
        )

    if force_include_end:
        q = len(target) / (n - 1)
        idx = [*[int(np.floor(i * q)) for i in range(n - 1)], -1]
    else:
        q = len(target) / n
        idx = [int(np.floor(i * q)) for i in range(n)]
    return target[idx]


def generate_diff_signals(
    variable_name: str,
    control_points: TimeSeries,
    valuation: Sequence[float],
    sampling_points: TimeSeries,
    max_deriv_order: int = 0,
) -> Dict[str, Signal]:
    """Generate a trace that consists of a signal over a given variable and its derivatives.
    The signal `x` is generated by a cubic spline interpolation of the control points.
    The derivatives are generated by taking the derivatives of the spline.
    Currently only n<=3 order of derivatives are supported.

    Args:
        variable_name: The name of the variable.
        control_points: Some timepoints to control the shape of the signal.
        valuation: The values of the signal at the control points. Must have the same length as
            `control_points`.
        times: The sampling points of the signal.
        max_deriv_order: The maximum order of derivatives to generate. Set to 0 to generate only
            the signal itself.

    Returns:
        A dictionary of signals. The key is the name of the signal, and the value is the signal.
        The derivatives are named as `x'`, `x''`, `x'''`, etc.
    """
    if max_deriv_order < 0:
        raise ValueError(
            "max_deriv_order=#{max_deriv_order} given."
            "Derivative order shoud be a non-negative integer."
        )
    elif max_deriv_order > 3:
        raise ValueError(
            "max_deriv_order=#{max_deriv_order} given."
            "Currently only n<=3 order of derivatives are supported."
        )

    spline = scipy.interpolate.CubicSpline(
        control_points,
        valuation,
        bc_type="natural",  # boundary condition. f''(0) == f''(T) == 0.
    )

    def nth_deriv(n):
        return Signal(spline(sampling_points, n), sampling_points)

    return {(variable_name + "'" * i): nth_deriv(i) for i in range(max_deriv_order + 1)}
