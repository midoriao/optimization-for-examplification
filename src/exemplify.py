import collections
import time
from dataclasses import dataclass
from typing import Callable, List, Optional, Sequence, Tuple, Union

import numpy as np
from cmaes import CMA
from signal_tl import compute_robustness

from .signal_processing import (
    TimeSeries,
    Trace,
    generate_diff_signals,
    pick_n_dividing_points,
)
from .specification import Spec

ErrorMessage = str


@dataclass(frozen=True)
class VariableConfig:
    """A user-specified configuration for a variable"""
    variable_name: str
    max_derivative_order: int = 0
    #    lb: float = - np.inf  # Currently not supported
    #    ub: float = np.inf
    n_control_points: int = 3


@dataclass(frozen=True)
class SignalGenerationData:
    """A utility dataclass to hold the data for generating a signal."""
    variable_name: str
    max_derivative_order: int
    control_points: TimeSeries
    start_index: int
    end_index: int
    sampling_points: TimeSeries


def generate_trace_for_variable(
    gen: SignalGenerationData,
    values_at_control_points: Sequence[float],
) -> Trace:
    return generate_diff_signals(
        gen.variable_name,
        gen.control_points,
        values_at_control_points,
        gen.sampling_points,
        gen.max_derivative_order,
    )


def cmaes_search(
    search_dim: int,
    values_to_trace: Callable[[Sequence[float]], Trace],
    spec_to_falsify: Spec,
    timeout_sec: float = 10.0,
    seed: Optional[int] = None,
) -> Tuple[Optional[Trace], ErrorMessage]:
    """Search for a falsifying trace using CMA-ES."""
    optimizer = CMA(
        mean=np.zeros(search_dim),  # Initial mean
        sigma=1.3,  # Initial standard deviation. sigma=1.3 is OK for most purposes.
        bounds=None,  # Lower and upper boundaries can be specified
        seed=seed,
    )

    t1 = time.time()
    elapsed = 0.0
    falsified_traces: List[Trace] = []

    while (
        len(falsified_traces) < 1
        and not optimizer.should_stop()
        and elapsed < timeout_sec
    ):
        solutions: List[Tuple[np.ndarray, float]] = []
        while len(solutions) < optimizer.population_size:  # Batch-evaluation
            x = optimizer.ask()
            trace = values_to_trace(x)
            try:
                robustness = compute_robustness(spec_to_falsify, trace).at(0)
            except IndexError:
                raise RuntimeError("Evaluation failed. Maybe some variables in spec are not in the trace?")
            except Exception:
                continue # Sometimes the evaluation fails. We can tolerate a few.
            if robustness < 0:
                falsified_traces.append(trace)
            solutions.append((x, robustness))
        if len(solutions) == 0:
            return (None, "Evaluation failed")
        else:
            optimizer.tell(solutions)
        elapsed = time.time() - t1

    if len(falsified_traces) > 0:
        return (falsified_traces[0], "Success")
    elif elapsed >= timeout_sec:
        return (None, f"Timeout after {elapsed:.2f} seconds")
    else:
        return (None, "Optimizer stopped")


def exemplify(
    spec: Spec,
    assumption: Spec,
    variables: Sequence[Union[VariableConfig, dict]],
    start_time: float,
    end_time: float,
    time_step: float = 0.1,
    postprocess_trace: Optional[Callable[[Trace], Trace]] = None,
    method: str = "CMA-ES",
    timeout_sec: float = 10.0,
    seed: Optional[int] = None,
) -> Tuple[Optional[Trace], ErrorMessage]:
    """Search for a trace that satisfies the spec.
    The signals are generated by numerical optimization.

    Args:
        spec: The STL formula specification to satisfy.
        assumption: The assumption formula. `signal_tl.TOP` if no assumption.
        variables: The configuration of variables to search for. The number of control points
            for each variable is specified by `n_control_points`. See `VariableConfig`.
        start_time: The start time of the signals.
        end_time: The end time of the signals.
        time_step: The time step of the signals, i.e., sampling rate is `1/time_step`.
        postprocess_trace: A function to postprocess the trace. For example, you can
            artificially add `sin(x)` signal based on `x` signal.
        method: The optimization method to use. Currently only "CMA-ES" is supported.
        timeout_sec: The timeout in seconds.

    Returns:
        A trace that satisfies the spec, or an error message.
        All signals in the trace are assumed to share the same time domain and sampling points.
    """
    # Check the input
    if any([not isinstance(c, dict) and not isinstance(c, VariableConfig) for c in variables]):
        raise ValueError("variables must be a sequence of VariableConfig or a correspondent dictionary.")
    variables = [VariableConfig(**c) if isinstance(c, dict) else c for c in variables]

    # Define basic data
    spec_to_falsify = ~(spec & assumption)
    sampling_points: TimeSeries = np.arange(
        start_time, end_time, time_step, dtype=float
    )

    # Preprocess the mapping from a sample from the search space to trace
    signal_generation_data: List[SignalGenerationData] = []
    idx = 0
    for config in variables:
        gen = SignalGenerationData(
            variable_name=config.variable_name,
            max_derivative_order=config.max_derivative_order,
            control_points=pick_n_dividing_points(
                sampling_points, config.n_control_points, force_include_end=True
            ),
            start_index=idx,
            end_index=idx + config.n_control_points,
            sampling_points=sampling_points,
        )
        signal_generation_data.append(gen)
        idx += config.n_control_points
    search_dim = idx

    # Closure
    def values_to_trace(values: Sequence[float]) -> Trace:
        trace: Trace = dict(collections.ChainMap(
            *[
                generate_trace_for_variable(
                    gen, values[gen.start_index : gen.end_index]
                )
                for gen in signal_generation_data
            ]
        ))
        if postprocess_trace is None:
            return trace
        else:
            return postprocess_trace(trace)

    # Search
    if method == "CMA-ES":
        try:
            return cmaes_search(
                search_dim, values_to_trace, spec_to_falsify, timeout_sec, seed
            )
        except Exception as e:
            return (None, f"Exception: {e}")
    else:
        raise ValueError(
            f"Unknown method: {method}. Currently only CMA-ES is supported."
        )
